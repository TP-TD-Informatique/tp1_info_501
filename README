# TP1 info501
# Kevin Traini

---

## Question 1

1. Fonction `simplify_formula` :

```python
simplified_F = [] # La formule simplifiée que l'on va retourner
for cl in F: # Pour chaque clause de la formule
    simplified_cl = [] # La clause simplifiée à rajouter
    for v in cl: # Pour chaque variable de la clause
        if v == lit: # Si la variable est vraie, on vide la clause simplifiée
            simplified_cl = []
            break # et on sort de la boucle

        if v != -lit: # Si la clause est une variable et n'est pas fausse
            simplified_cl.append(v) # on rajoute cette variable à la clause

        simplified_F.append(simplified_cl) # On la rajoute à la formule

return simplified_F
```

2. Sur la formule `(x1 ∨ ¬x2 ∨ x3) ∧ (¬x1 ∨ ¬x3 ∨ x4) ∧ (x2 ∨ ¬x4)` : Le fichier .sat

```
x1 ~x2 x3
~x1 ~x3 x4
x2 ~x4
```
Le résultat
```shell
$ ./naivesat-Traini.py test1.sat --test 1
simplification avec 1
avant : [[1, -2, 3], [-1, -3, 4], [2, -4]]
après : [[-3, 4], [2, -4]]
```

---

## Question 2

1. La formule `(a ∨ ¬b) ∧ (¬b ∨ ¬c) ∧ (¬a ∨ ¬c) ∧ (¬a ∨ ¬b ∨ c) ∧ (a ∨ b ∨ ¬c)` est satisfiable pour les valeurs `a ~b ~c` soit `a = 1, b = c = 0`

2. Pour trouver d'autres solutions, on empèche la première trouvée en ajoutant 3 clauses `¬a ∧ b ∧ c`. Dans ce cas présent la formule est insatisfiable. On en conclut qu'il n'existe qu'une seule solution pour que la formule de base soit satisfiable.

---

## Question 3

1. En partant de la fonction `solve`, on peut écrire la fonction `all_solutions` qui affiche toutes les solutions :

```python
if not F: # Si F est vide, alors F est satisfiable pour la solution sol
    print_sol(sol) # On affiche la solution
    return 1 # On renvoie 1 pour le compteur de solution

if [] in F: # Si F contient la clause vide, alors F n'est pas satisfiable
    return 0 # On renvoie 0 pour le compteur de solution

lit = F[0][0] # On récupère le premier littéral de la première clause
# On additionne le nombre de solution pour les 2 valeurs du littéral
return all_solutions(simplify_formula(F, lit), sol+[lit]) + all_solutions(simplify_formula(F, -lit), sol+[-lit])
```

2. Je renvoie le nombre de solution trouvé en additionnant les résultat renvoyé par les 2 essais, en renvoyant 1 quand satisfiable 0 sinon. Pour la formule `(x1 ∨ ¬x2 ∨ x3) ∧ (¬x1 ∨ ¬x3 ∨ x4) ∧ (x2 ∨ ¬x4)` j'ai :

```
x1 ~x3 x2
x1 ~x3 ~x2 ~x4
x1 x3 x4 x2
~x1 ~x2 ~x4
~x1 x2 x3
SATISFIABLE: 5 solution(s) found
```


---

## Question 4 (BONUS)

En testant plusieurs fois la satisfiabilité de la formule `(x1 ∨ ¬x2 ∨ x3) ∧ (¬x1 ∨ ¬x3 ∨ x4) ∧ (x2 ∨ ¬x4)` avec l'option `-r`, on remarque que la solution n'est pas la même. On peut expliquer ça du fait que l'algorithme commence par le début de la formule, donc le premier littéral qu'il rencontre détermine le reste de la solution qu'il va trouver.
